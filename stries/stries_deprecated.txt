// // 原生的链式结构 Tries
// template <typename Dummy = void> class [[deprecated]] STries : public TriesBase<STries<Dummy>> {
//     friend class TriesBase<STries<Dummy>>;

//     struct Node {
//         std::map<char, std::unique_ptr<Node>> children;
//         bool is_end = false;
//     };

//     std::unique_ptr<Node> root = std::make_unique<Node>();

//     // 深度优先搜索收集结果
//     void dfs(const Node *node, std::string &current_word, std::vector<std::string> &result,
//              SizeT limit) const noexcept {
//         if (result.size() >= limit) return;
//         if (node->is_end) {
//             result.push_back(current_word);
//             if (result.size() >= limit) return;
//         }

//         for (auto &[ch, child] : node->children) {
//             current_word.push_back(ch);
//             dfs(child.get(), current_word, result, limit);
//             current_word.pop_back();
//             if (result.size() >= limit) return;
//         }
//     }

//     // 定位前缀对应的节点
//     [[nodiscard]] const Node *find_node(std::string_view prefix) const noexcept {
//         const Node *current_node = root.get();
//         for (char ch : prefix) {
//             auto it = current_node->children.find(ch);
//             if (it == current_node->children.end()) return nullptr;
//             current_node = it->second.get();
//         }
//         return current_node;
//     }

//     void push_impl(std::string_view word) {
//         Node *current_node = root.get();
//         for (char ch : word) {
//             auto it = current_node->children.find(ch);
//             if (it == current_node->children.end()) {
//                 auto insert_result = current_node->children.try_emplace(ch, std::make_unique<Node>());
//                 it = insert_result.first;
//             }
//             current_node = it->second.get();
//         }
//         current_node->is_end = true;
//     }

//     [[nodiscard]] bool contains_impl(std::string_view word) const noexcept {
//         const Node *node = find_node(word);
//         return node != nullptr && node->is_end;
//     }

//     bool erase_impl(std::string_view word) {
//         Node *current_node = root.get();
//         std::vector<std::pair<Node *, char>> path; // 记录路径
//         path.reserve(word.size());

//         for (char ch : word) {
//             auto it = current_node->children.find(ch);
//             if (it == current_node->children.end()) return false; // word 不存在
//             path.emplace_back(current_node, ch);
//             current_node = it->second.get();
//         }

//         if (!current_node->is_end) return false; // 当前单词仅为前缀，非完整单词
//         current_node->is_end = false;            // 把单词末尾标记为非 end
//         if (!current_node->children.empty()) return true;

//         for (auto it = path.rbegin(); it != path.rend(); ++it) {
//             Node *parent = it->first;
//             char edge = it->second;
//             auto child_it = parent->children.find(edge);
//             if (child_it == parent->children.end()) [[unlikely]]
//                 break;

//             const Node *child = child_it->second.get();
//             if (child->is_end || !child->children.empty()) break; // 不作为某单词的结尾，也不属于任何单词的前缀部分
//             parent->children.erase(child_it);
//         }
//         return true;
//     }

//     [[nodiscard]] bool contains_starts_with_impl(std::string_view prefix) const noexcept { return find_node(prefix);
//     }

//     [[nodiscard]] std::vector<std::string> prefix_search_impl(std::string_view prefix, SizeT limit = SizeMax) const {
//         const Node *start_node = find_node(prefix);
//         if (start_node == nullptr) return {};

//         std::vector<std::string> result;
//         result.reserve(limit == SizeMax ? 16 : limit);
//         std::string current_word(prefix);
//         current_word.reserve(prefix.size() + 32);
//         dfs(start_node, current_word, result, limit);
//         return result;
//     }

//     [[nodiscard]] std::string_view longest_prefix_of_impl(std::string_view) const noexcept { return {}; }

// public:
//     STries() = default;
// };

// // 使用对象池存储节点
// template <typename Dummy = void> class [[deprecated]] SFlatTries : public TriesBase<SFlatTries<Dummy>> {
//     friend class TriesBase<SFlatTries<Dummy>>;

//     struct Node {
//         std::map<char, UInt32> children;
//         bool is_end = false;
//     };

//     std::vector<Node> node_pool; // index 是在池中的下标
//     static constexpr UInt32 invalid_index = std::numeric_limits<UInt32>::max();

//     UInt32 create_node() {
//         node_pool.emplace_back();
//         return static_cast<UInt32>(node_pool.size() - 1);
//     }

//     void dfs(UInt32 node_index, std::string &current_word, std::vector<std::string> &result,
//              SizeT limit) const noexcept {
//         if (result.size() >= limit) return;
//         const Node &current_node = node_pool[node_index];
//         if (current_node.is_end) {
//             result.push_back(current_word);
//             if (result.size() >= limit) return;
//         }

//         for (const auto &[ch, child_node_index] : current_node.children) {
//             current_word.push_back(ch);
//             dfs(child_node_index, current_word, result, limit);
//             current_word.pop_back();
//             if (result.size() >= limit) return;
//         }
//     }

//     [[nodiscard]] UInt32 find_node_index(std::string_view prefix) const noexcept {
//         if (node_pool.empty()) [[unlikely]]
//             return invalid_index;
//         UInt32 current_node_index = 0; // root
//         for (char ch : prefix) {
//             const Node &current_node = node_pool[current_node_index];
//             auto it = current_node.children.find(ch);
//             if (it == current_node.children.end()) return invalid_index;
//             current_node_index = it->second;
//         }
//         return current_node_index;
//     }

//     void push_impl(std::string_view word) {
//         UInt32 current_node_index = 0; // root
//         for (char ch : word) {
//             // 这里不应该使用引用，即便是单线程，create node 也会导致悬空引用
//             auto it = node_pool[current_node_index].children.find(ch);
//             if (it == node_pool[current_node_index].children.end()) {
//                 UInt32 child_node_index = create_node(); // 此处可能导致 reallocate
//                 node_pool[current_node_index].children.try_emplace(ch, child_node_index);
//                 current_node_index = child_node_index;
//             } else {
//                 current_node_index = it->second;
//             }
//         }
//         node_pool[current_node_index].is_end = true;
//     }

//     [[nodiscard]] bool contains_impl(std::string_view word) const noexcept {
//         UInt32 node_index = find_node_index(word);
//         return node_index != invalid_index && node_pool[node_index].is_end;
//     }

//     bool erase_impl(std::string_view word) {
//         UInt32 current_node_index = 0; // root
//         std::vector<std::pair<UInt32, char>> path;
//         path.reserve(word.size());

//         for (char ch : word) {
//             Node &current_node = node_pool[current_node_index];
//             auto it = current_node.children.find(ch);
//             if (it == current_node.children.end()) return false;
//             path.emplace_back(current_node_index, ch);
//             current_node_index = it->second;
//         }

//         Node &terminal_node = node_pool[current_node_index];
//         if (!terminal_node.is_end) return false;
//         terminal_node.is_end = false;
//         if (!terminal_node.children.empty()) return true;

//         for (auto it = path.rbegin(); it != path.rend(); ++it) {
//             UInt32 parent_index = it->first;
//             char edge = it->second;
//             Node &parent_node = node_pool[parent_index];
//             auto child_it = parent_node.children.find(edge);
//             if (child_it == parent_node.children.end()) [[unlikely]]
//                 break;

//             UInt32 child_node_index = child_it->second;
//             const Node &child_node = node_pool[child_node_index];
//             if (child_node.is_end || !child_node.children.empty()) break;
//             parent_node.children.erase(child_it);
//         }
//         return true;
//     }

//     [[nodiscard]] bool contains_starts_with_impl(std::string_view prefix) const noexcept {
//         return find_node_index(prefix) != invalid_index;
//     }

//     [[nodiscard]] std::vector<std::string> prefix_search_impl(std::string_view prefix, SizeT limit = SizeMax) const {
//         UInt32 start_node_index = find_node_index(prefix);
//         if (start_node_index == invalid_index) return {};

//         std::vector<std::string> result;
//         result.reserve(limit == SizeMax ? 16 : limit);
//         std::string current_word(prefix);
//         current_word.reserve(prefix.size() + 32);
//         dfs(start_node_index, current_word, result, limit);
//         return result;
//     }

// public:
//     SFlatTries() : node_pool() {
//         node_pool.reserve(1024);
//         create_node();
//     }
// };

// // 允许用户提供 memory resource
// template <typename Dummy = void> class [[deprecated]] SPmrFlatTries : public TriesBase<SPmrFlatTries<Dummy>> {
//     friend class TriesBase<SPmrFlatTries<Dummy>>;

//     struct Node {
//         std::pmr::map<char, UInt32> children;
//         bool is_end = false;
//         explicit Node(std::pmr::memory_resource *resource) noexcept : children(resource) {}
//     };

//     std::pmr::vector<Node> node_pool;
//     std::pmr::memory_resource *memory_resource;
//     static constexpr UInt32 invalid_index = std::numeric_limits<UInt32>::max();

//     UInt32 create_node() {
//         node_pool.emplace_back(memory_resource);
//         return static_cast<UInt32>(node_pool.size() - 1);
//     }

//     void dfs(UInt32 node_index, std::string &current_word, std::vector<std::string> &result,
//              SizeT limit) const noexcept {
//         if (result.size() >= limit) return;
//         const Node &current_node = node_pool[node_index];
//         if (current_node.is_end) {
//             result.push_back(current_word);
//             if (result.size() >= limit) return;
//         }

//         for (const auto &[ch, child_node_index] : current_node.children) {
//             current_word.push_back(ch);
//             dfs(child_node_index, current_word, result, limit);
//             current_word.pop_back();
//             if (result.size() >= limit) return;
//         }
//     }

//     [[nodiscard]] UInt32 find_node_index(std::string_view prefix) const noexcept {
//         if (node_pool.empty()) [[unlikely]]
//             return invalid_index;
//         UInt32 current_node_index = 0; // root
//         for (char ch : prefix) {
//             const Node &current_node = node_pool[current_node_index];
//             auto it = current_node.children.find(ch);
//             if (it == current_node.children.end()) return invalid_index;
//             current_node_index = it->second;
//         }
//         return current_node_index;
//     }

//     void push_impl(std::string_view word) {
//         UInt32 current_node_index = 0; // root
//         for (char ch : word) {
//             // 这里不应该使用引用，即便是单线程，create node 也会导致悬空引用
//             auto it = node_pool[current_node_index].children.find(ch);
//             if (it == node_pool[current_node_index].children.end()) {
//                 UInt32 child_node_index = create_node();
//                 node_pool[current_node_index].children.try_emplace(ch, child_node_index);
//                 current_node_index = child_node_index;
//             } else {
//                 current_node_index = it->second;
//             }
//         }
//         node_pool[current_node_index].is_end = true;
//     }

//     [[nodiscard]] bool contains_impl(std::string_view word) const noexcept {
//         UInt32 node_index = find_node_index(word);
//         return node_index != invalid_index && node_pool[node_index].is_end;
//     }

//     bool erase_impl(std::string_view word) {
//         UInt32 current_node_index = 0; // root
//         std::pmr::vector<std::pair<UInt32, char>> path(memory_resource);
//         path.reserve(word.size());
//         for (char ch : word) {
//             Node &current_node = node_pool[current_node_index];
//             auto it = current_node.children.find(ch);
//             if (it == current_node.children.end()) return false;
//             path.emplace_back(current_node_index, ch);
//             current_node_index = it->second;
//         }

//         Node &terminal_node = node_pool[current_node_index];
//         if (!terminal_node.is_end) return false;
//         terminal_node.is_end = false;
//         if (!terminal_node.children.empty()) return true;

//         for (auto it = path.rbegin(); it != path.rend(); ++it) {
//             UInt32 parent_index = it->first;
//             char edge = it->second;
//             Node &parent_node = node_pool[parent_index];
//             auto child_it = parent_node.children.find(edge);
//             if (child_it == parent_node.children.end()) [[unlikely]]
//                 break;

//             UInt32 child_node_index = child_it->second;
//             const Node &child_node = node_pool[child_node_index];
//             if (child_node.is_end || !child_node.children.empty()) break;
//             parent_node.children.erase(child_it);
//         }
//         return true;
//     }

//     [[nodiscard]] bool contains_starts_with_impl(std::string_view prefix) const noexcept {
//         return find_node_index(prefix) != invalid_index;
//     }

//     [[nodiscard]] std::vector<std::string> prefix_search_impl(std::string_view prefix, SizeT limit = SizeMax) const {
//         UInt32 start_node_index = find_node_index(prefix);
//         if (start_node_index == invalid_index) return {};

//         std::vector<std::string> result;
//         result.reserve(limit == SizeMax ? 16 : limit);
//         std::string current_word(prefix);
//         current_word.reserve(prefix.size() + 32);
//         dfs(start_node_index, current_word, result, limit);
//         return result;
//     }

// public:
//     explicit SPmrFlatTries(std::pmr::memory_resource *resource) : node_pool(resource), memory_resource(resource) {
//         node_pool.reserve(1024);
//         create_node();
//     }
// };